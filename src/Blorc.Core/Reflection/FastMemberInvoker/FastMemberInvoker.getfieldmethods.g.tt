<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	var typeCodes = Enum.GetValues(typeof(TypeCode));
#>
//------------------------------------------------------------------------------ 
// <auto-generated> 
// This code was generated by a tool. 
// 
// Changes to this file may cause incorrect behavior and will be lost if 
// the code is regenerated. 
// </auto-generated> 
//------------------------------------------------------------------------------

namespace Catel.Reflection
{
    using System;
    using Catel.Data;

    public partial class FastMemberInvoker<TEntity>
    {
        public bool TryGetFieldValue<TValue>(object entity, string fieldName, out TValue value)
        {
            if (!typeof(TValue).IsValueTypeEx())
            {
                object localValue;

                if (TryGetFieldValue((TEntity)entity, fieldName, out localValue))
                {
                    // Already object, so no need to work around boxing
                    value = (TValue)localValue;
                    return true;
                }
                else
                {
                    value = default;
                    return false;
                }
            }

<# 
foreach (TypeCode typeCode in typeCodes) 
{
    if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}

#>
            if (typeof(TValue) == typeof(<#= typeCode #>))
            {
                <#= typeCode #> localValue;

                if (TryGetFieldValue((TEntity)entity, fieldName, out localValue))
                {
                    // This prevents the requirement for boxing, see https://github.com/Catel/Catel/issues/1450
                    var tr = __makeref(localValue);
                    value = __refvalue(tr, TValue);
                    return true;
                }
                else
                {
                    value = default;
                    return false;
                }
            }

<#
}
#>
            value = default;
            return false;
        }

<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull)
	{
		continue;
	}

	string typeCodeGetterCacheName = "_" + typeCode.ToString().ToLowerInvariant() + "FieldGettersCache";
#>
        public bool TryGetFieldValue(TEntity entity, string fieldName, out <#= typeCode #> item)
        {
            var getter = Get<#= typeCode #>FieldGetter(fieldName);
            if (getter != null)
            {
                item = getter(entity);
                return true;
            }

            item = default;
            return false;
        }

<# } #>
    }
}